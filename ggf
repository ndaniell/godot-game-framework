#!/bin/bash

# Godot Game Framework - Central management script
# Note: set -e is not used globally to allow proper error handling in test command

# Configuration
GODOT_URL="https://downloads.godotengine.org/?version=4.5.1&flavor=stable&slug=linux.x86_64.zip&platform=linux.64"
GODOT_DIR="godot"
TEMP_ZIP="/tmp/godot_linux.zip"

# Check if colors are supported
if [ -t 1 ] && command -v tput > /dev/null 2>&1; then
    # Terminal supports colors
    RED=$(tput setaf 1)
    GREEN=$(tput setaf 2)
    YELLOW=$(tput setaf 3)
    BLUE=$(tput setaf 4)
    BOLD=$(tput bold)
    NC=$(tput sgr0) # No Color
else
    # No color support
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    BOLD=''
    NC=''
fi

# Print help message
show_help() {
    echo "${BLUE}Godot Game Framework (ggf)${NC}"
    echo
    echo "A central script for managing your Godot game framework project."
    echo
    echo "${GREEN}Usage:${NC}"
    echo "    ggf <command> [options]"
    echo
    echo "${GREEN}Commands:${NC}"
    echo "    ${YELLOW}install${NC}           Download and install Godot engine"
    echo "    ${YELLOW}test [--verbose]${NC}  Run framework tests (use --verbose to see all warnings)"
    echo "    ${YELLOW}lint${NC}              Lint addon GDScript (gdlint)"
    echo "    ${YELLOW}format [--check]${NC}  Format addon GDScript (gdformat)"
    echo "    ${YELLOW}export [options]${NC}  Export the project using presets in export_presets.cfg"
    echo "    ${YELLOW}release <kind>${NC}    Create a release: bump version, commit, tag, and push (kind: patch|minor|major)"
    echo "    ${YELLOW}help${NC}              Show this help message"
    echo
    echo "${GREEN}Lint/format options:${NC}"
    echo "    ${YELLOW}--check${NC}           For format: do not write changes; exit non-zero if changes needed"
    echo "    ${YELLOW}--diff${NC}            For format --check: print unified diff"
    echo
    echo "${GREEN}Export options:${NC}"
    echo "    ${YELLOW}--list${NC}            List available export presets"
    echo "    ${YELLOW}--preset <name>${NC}   Export only the given preset (can be repeated)"
    echo "    ${YELLOW}--debug${NC}           Export in debug mode (default: release)"
    echo
    echo "${GREEN}Examples:${NC}"
    echo "    ggf install          Install Godot 4.5.1"
    echo "    ggf test             Run all framework tests"
    echo "    ggf test --verbose   Run tests with verbose output (shows all warnings)"
    echo "    ggf lint             Run gdlint on addons/godot_game_framework"
    echo "    ggf format           Run gdformat on addons/godot_game_framework (writes changes)"
    echo "    ggf format --check --diff  Check formatting (CI-friendly)"
    echo "    ggf export           Export all presets defined in export_presets.cfg"
    echo "    ggf export --list    List export presets"
    echo "    ggf export --preset \"Linux\"     Export only the Linux preset"
    echo "    ggf release patch    Bump 0.1.0 -> 0.1.1, commit, tag v0.1.1, push main + tag"
    echo "    ggf help             Show this help message"
    echo
    echo "${GREEN}For more information, visit:${NC} https://godotengine.org/"
}

require_command() {
    local cmd="$1"
    local human_name="$2"

    if command -v "$cmd" > /dev/null 2>&1; then
        return 0
    fi

    echo "${RED}Error: '$cmd' not found.${NC}"
    echo "${YELLOW}Install ${human_name} locally to use this command.${NC}"
    echo "${YELLOW}Tip: see requirements-dev.txt and the CI workflow for the exact tools used.${NC}"
    return 1
}

require_git_repo() {
    require_command "git" "git" || exit 1
    if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
        echo "${RED}Error: Not inside a git repository.${NC}"
        exit 1
    fi
}

require_clean_worktree() {
    local status
    status="$(git status --porcelain)"
    if [ -n "$status" ]; then
        echo "${RED}Error: Working tree is not clean.${NC}"
        echo "${YELLOW}Commit or stash changes before releasing.${NC}"
        exit 1
    fi
}

require_on_main_branch() {
    local branch
    branch="$(git rev-parse --abbrev-ref HEAD 2>/dev/null || true)"
    if [ "$branch" != "main" ]; then
        echo "${RED}Error: Release must be created from branch 'main' (current: '$branch').${NC}"
        exit 1
    fi
}

require_origin_remote() {
    if ! git remote get-url origin > /dev/null 2>&1; then
        echo "${RED}Error: 'origin' remote not found.${NC}"
        exit 1
    fi
}

require_not_behind_origin_main() {
    # Make sure origin/main exists locally
    if ! git show-ref --verify --quiet refs/remotes/origin/main; then
        echo "${BLUE}Fetching origin/main and tags...${NC}"
        git fetch --tags origin main
    fi

    local counts behind ahead
    counts="$(git rev-list --left-right --count origin/main...HEAD 2>/dev/null || true)"
    if [ -z "$counts" ]; then
        echo "${RED}Error: Could not compare HEAD to origin/main.${NC}"
        exit 1
    fi
    behind="$(echo "$counts" | awk '{print $1}')"
    ahead="$(echo "$counts" | awk '{print $2}')"

    if [ "${behind:-0}" -ne 0 ]; then
        if [ "${ahead:-0}" -ne 0 ]; then
            echo "${RED}Error: Local main has diverged from origin/main (behind=$behind, ahead=$ahead).${NC}"
        else
            echo "${RED}Error: Local main is behind origin/main by $behind commit(s).${NC}"
        fi
        echo "${YELLOW}Pull/rebase main before running release.${NC}"
        exit 1
    fi
}

read_plugin_version() {
    local plugin_cfg="addons/godot_game_framework/plugin.cfg"
    if [ ! -f "$plugin_cfg" ]; then
        echo ""
        return 1
    fi
    # Extract version="X.Y.Z"
    local v
    v="$(sed -n -E 's/^version="([^"]+)".*$/\1/p' "$plugin_cfg" | head -n 1)"
    if [ -z "$v" ]; then
        echo ""
        return 1
    fi
    echo "$v"
}

is_semver() {
    local v="$1"
    [[ "$v" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]
}

bump_semver() {
    local v="$1"
    local kind="$2"

    local major minor patch
    IFS='.' read -r major minor patch <<< "$v"

    case "$kind" in
        patch)
            patch=$((patch + 1))
            ;;
        minor)
            minor=$((minor + 1))
            patch=0
            ;;
        major)
            major=$((major + 1))
            minor=0
            patch=0
            ;;
        *)
            return 1
            ;;
    esac

    echo "${major}.${minor}.${patch}"
}

write_plugin_version() {
    local new_version="$1"
    local plugin_cfg="addons/godot_game_framework/plugin.cfg"

    if [ ! -f "$plugin_cfg" ]; then
        echo "${RED}Error: Could not find $plugin_cfg${NC}"
        exit 1
    fi

    # Replace only the version line.
    # Keep it simple/strict: require the line to start with version="
    if ! grep -qE '^version="' "$plugin_cfg"; then
        echo "${RED}Error: Could not find version line in $plugin_cfg${NC}"
        exit 1
    fi

    sed -i -E 's/^version="[^"]*"/version="'"$new_version"'"/' "$plugin_cfg"
}

cmd_release() {
    set -euo pipefail

    local kind="${1:-}"
    if [ -z "$kind" ]; then
        echo "${RED}Error: Missing release kind.${NC}"
        echo "${YELLOW}Usage: ggf release patch|minor|major${NC}"
        exit 1
    fi

    case "$kind" in
        patch|minor|major) ;;
        *)
            echo "${RED}Error: Unknown release kind '$kind'.${NC}"
            echo "${YELLOW}Usage: ggf release patch|minor|major${NC}"
            exit 1
            ;;
    esac

    echo "${BLUE}Creating release (${BOLD}${kind}${NC}${BLUE})...${NC}"

    require_git_repo
    require_on_main_branch
    require_clean_worktree
    require_origin_remote

    echo "${BLUE}Fetching origin/main and tags...${NC}"
    git fetch --tags origin main
    require_not_behind_origin_main

    local current_version
    current_version="$(read_plugin_version)" || true
    if [ -z "$current_version" ]; then
        echo "${RED}Error: Could not read current version from addons/godot_game_framework/plugin.cfg${NC}"
        exit 1
    fi
    if ! is_semver "$current_version"; then
        echo "${RED}Error: Current version is not semver (X.Y.Z): '$current_version'${NC}"
        exit 1
    fi

    local new_version
    new_version="$(bump_semver "$current_version" "$kind")" || true
    if [ -z "$new_version" ]; then
        echo "${RED}Error: Failed to bump version '${current_version}' with kind '${kind}'.${NC}"
        exit 1
    fi

    local tag="v${new_version}"
    if git rev-parse -q --verify "refs/tags/${tag}" > /dev/null 2>&1; then
        echo "${RED}Error: Tag '${tag}' already exists.${NC}"
        exit 1
    fi

    echo "${BLUE}Bumping version: ${YELLOW}${current_version}${NC} -> ${YELLOW}${new_version}${NC}"
    write_plugin_version "$new_version"

    echo "${BLUE}Committing version bump...${NC}"
    git add addons/godot_game_framework/plugin.cfg
    git commit -m "chore(release): ${tag}"

    echo "${BLUE}Tagging release...${NC}"
    git tag -a "${tag}" -m "${tag}"

    echo "${BLUE}Pushing main and tag to origin...${NC}"
    git push origin main
    git push origin "${tag}"

    echo "${GREEN}✓ Release created: ${BOLD}${tag}${NC}${GREEN}${NC}"
    echo "${GREEN}  GitHub Actions should create a release when the tag is pushed.${NC}"
}

# Lint addon GDScript
cmd_lint() {
    echo "${BLUE}Linting addon GDScript...${NC}"
    require_command "gdlint" "gdtoolkit" || exit 1

    gdlint addons/godot_game_framework
}

# Format addon GDScript
cmd_format() {
    local CHECK=false
    local DIFF=false

    while [[ $# -gt 0 ]]; do
        case $1 in
            --check)
                CHECK=true
                shift
                ;;
            --diff)
                DIFF=true
                shift
                ;;
            *)
                echo "${YELLOW}Unknown option: $1${NC}"
                echo "Use 'ggf help' for format options"
                shift
                ;;
        esac
    done

    echo "${BLUE}Formatting addon GDScript...${NC}"
    require_command "gdformat" "gdtoolkit" || exit 1

    if [ "$CHECK" = true ]; then
        if [ "$DIFF" = true ]; then
            gdformat --check --diff addons/godot_game_framework
        else
            gdformat --check addons/godot_game_framework
        fi
    else
        gdformat addons/godot_game_framework
    fi
}

# Install Godot engine
cmd_install() {
    set -e  # Enable strict error handling for install
    echo "${BLUE}Installing Godot 4.5.1...${NC}"
    
    # Create godot directory if it doesn't exist
    mkdir -p "$GODOT_DIR"
    
    # Check if already installed
    if [ -f "$GODOT_DIR/Godot"* ] || [ -f "$GODOT_DIR/godot"* ]; then
        echo "${YELLOW}Godot appears to already be installed in $GODOT_DIR/${NC}"
        read -p "Do you want to reinstall? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "${GREEN}Installation cancelled.${NC}"
            exit 0
        fi
        rm -rf "$GODOT_DIR"/*
    fi
    
    # Download Godot
    echo "${BLUE}Downloading Godot 4.5.1...${NC}"
    if ! curl -L -o "$TEMP_ZIP" "$GODOT_URL"; then
        echo "${RED}Error: Failed to download Godot${NC}"
        exit 1
    fi
    
    # Extract the zip file
    echo "${BLUE}Extracting Godot...${NC}"
    if ! unzip -q "$TEMP_ZIP" -d "$GODOT_DIR"; then
        echo "${RED}Error: Failed to extract Godot${NC}"
        rm -f "$TEMP_ZIP"
        exit 1
    fi
    
    # Find the executable in the extracted files
    EXECUTABLE=$(find "$GODOT_DIR" -type f -name "Godot*" -executable | head -n 1)
    
    if [ -z "$EXECUTABLE" ]; then
        # If no executable found, try to find any file named Godot*
        EXECUTABLE=$(find "$GODOT_DIR" -type f -name "Godot*" | head -n 1)
        if [ -n "$EXECUTABLE" ]; then
            chmod +x "$EXECUTABLE"
        fi
    fi
    
    # If executable is in a subdirectory, move it to the godot root
    if [ -n "$EXECUTABLE" ]; then
        EXECUTABLE_DIR=$(dirname "$EXECUTABLE")
        GODOT_DIR_ABS=$(realpath "$GODOT_DIR")
        EXECUTABLE_DIR_ABS=$(realpath "$EXECUTABLE_DIR")
        
        # Only move if the executable is in a subdirectory (not already in godot root)
        if [ "$EXECUTABLE_DIR_ABS" != "$GODOT_DIR_ABS" ]; then
            echo "${BLUE}Moving executable to $GODOT_DIR/...${NC}"
            mv "$EXECUTABLE" "$GODOT_DIR/"
            # Update EXECUTABLE path after move
            EXECUTABLE="$GODOT_DIR/$(basename "$EXECUTABLE")"
            # Clean up empty subdirectories
            find "$GODOT_DIR" -type d -empty -delete
        fi
    fi
    
    # Clean up temporary zip file
    rm -f "$TEMP_ZIP"
    
    # Verify installation
    if [ -n "$EXECUTABLE" ]; then
        EXECUTABLE_NAME=$(basename "$EXECUTABLE")
        if [ -f "$GODOT_DIR/$EXECUTABLE_NAME" ]; then
            echo "${GREEN}✓ Godot has been successfully installed!${NC}"
            echo "${GREEN}  Location: $GODOT_DIR/$EXECUTABLE_NAME${NC}"
        else
            echo "${YELLOW}⚠ Installation completed, but executable location may vary${NC}"
        fi
    else
        echo "${RED}Error: Could not find Godot executable after extraction${NC}"
        exit 1
    fi
}

# Find Godot executable
find_godot_executable() {
    # Check common locations
    if [ -f "$GODOT_DIR/Godot_v4.5.1-stable_linux.x86_64" ]; then
        echo "$GODOT_DIR/Godot_v4.5.1-stable_linux.x86_64"
        return 0
    fi
    
    # Try to find any Godot executable in the godot directory
    local executable=$(find "$GODOT_DIR" -type f -name "Godot*" -executable 2>/dev/null | head -n 1)
    if [ -n "$executable" ]; then
        echo "$executable"
        return 0
    fi
    
    # Try system Godot
    if command -v godot > /dev/null 2>&1; then
        echo "godot"
        return 0
    fi
    
    return 1
}

# Parse export presets from export_presets.cfg.
# Output format: <preset_name>\t<export_path>
list_export_presets() {
    if [ ! -f "export_presets.cfg" ]; then
        return 1
    fi

    awk '
        BEGIN { name=""; path=""; }
        /^\[preset\.[0-9]+\]$/ {
            if (name != "") {
                printf("%s\t%s\n", name, path);
            }
            name=""; path="";
            next;
        }
        /^name="/ {
            line=$0;
            sub(/^name="/, "", line);
            sub(/"$/, "", line);
            name=line;
            next;
        }
        /^export_path="/ {
            line=$0;
            sub(/^export_path="/, "", line);
            sub(/"$/, "", line);
            path=line;
            next;
        }
        END {
            if (name != "") {
                printf("%s\t%s\n", name, path);
            }
        }
    ' export_presets.cfg
}

# Export project using export presets.
cmd_export() {
    local MODE="release"
    local LIST_ONLY=false
    local -a REQUESTED_PRESETS=()

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --list)
                LIST_ONLY=true
                shift
                ;;
            --preset)
                if [ -z "${2:-}" ]; then
                    echo "${RED}Error: --preset requires a value${NC}"
                    exit 1
                fi
                REQUESTED_PRESETS+=("$2")
                shift 2
                ;;
            --debug)
                MODE="debug"
                shift
                ;;
            --release)
                MODE="release"
                shift
                ;;
            *)
                echo "${YELLOW}Unknown option: $1${NC}"
                shift
                ;;
        esac
    done

    echo "${BLUE}Exporting project (${MODE})...${NC}"

    # Find Godot executable
    GODOT_EXEC=$(find_godot_executable)
    local find_exit=$?
    if [ $find_exit -ne 0 ] || [ -z "$GODOT_EXEC" ]; then
        echo "${RED}Error: Could not find Godot executable${NC}"
        echo "${YELLOW}Please install Godot first using: ggf install${NC}"
        exit 1
    fi

    # Check if project.godot exists
    if [ ! -f "project.godot" ]; then
        echo "${RED}Error: project.godot not found${NC}"
        echo "${YELLOW}Please run this command from the framework root directory${NC}"
        exit 1
    fi

    # Check export presets file
    if [ ! -f "export_presets.cfg" ]; then
        echo "${RED}Error: export_presets.cfg not found${NC}"
        echo "${YELLOW}Create export presets in the Godot editor (Project > Export) first.${NC}"
        exit 1
    fi

    local presets_output
    presets_output="$(list_export_presets)"
    if [ -z "$presets_output" ]; then
        echo "${RED}Error: No export presets found in export_presets.cfg${NC}"
        exit 1
    fi

    if [ "$LIST_ONLY" = true ]; then
        echo "${GREEN}Available export presets:${NC}"
        echo "$presets_output" | while IFS=$'\t' read -r preset_name preset_path; do
            printf "  - %s -> %s\n" "$preset_name" "$preset_path"
        done
        exit 0
    fi

    # Build a lookup table of preset -> export_path
    declare -A PRESET_PATHS
    while IFS=$'\t' read -r preset_name preset_path; do
        PRESET_PATHS["$preset_name"]="$preset_path"
    done <<< "$presets_output"

    # Determine which presets to export
    local -a PRESETS_TO_EXPORT=()
    if [ ${#REQUESTED_PRESETS[@]} -gt 0 ]; then
        PRESETS_TO_EXPORT=("${REQUESTED_PRESETS[@]}")
    else
        while IFS=$'\t' read -r preset_name preset_path; do
            PRESETS_TO_EXPORT+=("$preset_name")
        done <<< "$presets_output"
    fi

    local failures=0
    for preset in "${PRESETS_TO_EXPORT[@]}"; do
        if [[ -z "${PRESET_PATHS[$preset]+x}" ]]; then
            echo "${RED}Error: Unknown preset: $preset${NC}"
            echo "${YELLOW}Use: ggf export --list${NC}"
            exit 1
        fi

        local out_path="${PRESET_PATHS[$preset]}"
        if [ -z "$out_path" ]; then
            echo "${RED}Error: Preset '$preset' has no export_path set in export_presets.cfg${NC}"
            failures=$((failures + 1))
            continue
        fi

        local out_dir
        out_dir="$(dirname "$out_path")"
        mkdir -p "$out_dir"

        echo "${BLUE}Exporting preset: ${BOLD}${preset}${NC} -> ${YELLOW}${out_path}${NC}"
        if [ "$MODE" = "debug" ]; then
            "$GODOT_EXEC" --headless --export-debug "$preset" "$out_path" 2>&1
        else
            "$GODOT_EXEC" --headless --export-release "$preset" "$out_path" 2>&1
        fi
        local export_exit=$?
        if [ $export_exit -ne 0 ]; then
            echo "${RED}✗ Export failed for preset '$preset' (exit code: $export_exit)${NC}"
            failures=$((failures + 1))
        else
            echo "${GREEN}✓ Exported '$preset'${NC}"
        fi
        echo
    done

    if [ $failures -ne 0 ]; then
        echo "${RED}✗ Export finished with $failures failure(s).${NC}"
        exit 1
    fi

    echo "${GREEN}✓ Export completed successfully.${NC}"
    exit 0
}

# Run tests
cmd_test() {
    # Don't use set -e here, we need to capture exit codes
    local VERBOSE=false
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --verbose|-v)
                VERBOSE=true
                shift
                ;;
            *)
                echo "${YELLOW}Unknown option: $1${NC}"
                echo "Use 'ggf test --verbose' to see all warnings"
                shift
                ;;
        esac
    done
    
    echo "${BLUE}Running framework tests...${NC}"
    
    # Find Godot executable
    GODOT_EXEC=$(find_godot_executable)
    local find_exit=$?
    if [ $find_exit -ne 0 ] || [ -z "$GODOT_EXEC" ]; then
        echo "${RED}Error: Could not find Godot executable${NC}"
        echo "${YELLOW}Please install Godot first using: ggf install${NC}"
        exit 1
    fi
    
    # Check if project.godot exists
    if [ ! -f "project.godot" ]; then
        echo "${RED}Error: project.godot not found${NC}"
        echo "${YELLOW}Please run this command from the framework root directory${NC}"
        exit 1
    fi
    
    # Create a test runner script that will execute tests
    TEST_SCRIPT="/tmp/ggf_test_runner.gd"
    cat > "$TEST_SCRIPT" << 'EOF'
extends SceneTree

func _initialize():
    # Wait for managers to initialize
    # When extending SceneTree, we are the tree, so use 'self' or direct calls
    await process_frame
    await process_frame
    
    # Load and run test runner
    var test_runner_script = load("res://addons/godot_game_framework/tests/TestRunner.gd")
    if test_runner_script == null:
        print("ERROR: Could not load TestRunner.gd")
        quit(1)
        return
    
    var test_runner = test_runner_script.new()
    root.add_child(test_runner)
    
    # Clear script reference after creating instance to help with cleanup
    # (Script resources are cached by ResourceLoader, but clearing our reference helps)
    test_runner_script = null
    
    # Tests run automatically if auto_run_on_ready is true
    # TestRunner will quit itself when tests complete via call_deferred
    # Wait for quit to happen - use a simple loop instead of timer to avoid leak
    # TestRunner should quit quickly, but we'll wait up to 30 seconds as safety
    var max_wait = 30.0
    var elapsed = 0.0
    var delta = 1.0 / 60.0  # Approximate frame time
    
    while elapsed < max_wait:
        await process_frame
        elapsed += delta
        # Check if quit was requested (we can't easily check this, so just wait)
        # TestRunner will call quit() which will exit the loop
    
    # If we reach here, something went wrong - clean up and force quit
    if is_instance_valid(test_runner):
        root.remove_child(test_runner)
        test_runner.free()
        await process_frame
    quit(1)
EOF
    
    echo "${BLUE}Executing tests with Godot (headless mode)...${NC}"
    if [ "$VERBOSE" = true ]; then
        echo "${YELLOW}Verbose mode: All warnings and errors will be shown${NC}"
        # Run with --verbose flag for extra details
        "$GODOT_EXEC" --headless --verbose --script "$TEST_SCRIPT" 2>&1
    else
        echo "${YELLOW}Note: Test output will appear below${NC}"
        # Run normally - warnings/errors will show if there are actual issues
        "$GODOT_EXEC" --headless --script "$TEST_SCRIPT" 2>&1
    fi
    TEST_EXIT_CODE=$?
    
    # Clean up
    rm -f "$TEST_SCRIPT"
    
    echo
    
    if [ $TEST_EXIT_CODE -eq 0 ]; then
        echo "${GREEN}✓ Tests completed!${NC}"
        echo "${GREEN}Check the output above for test results.${NC}"
        exit 0
    else
        echo "${RED}✗ Tests failed or encountered errors (exit code: $TEST_EXIT_CODE)${NC}"
        exit $TEST_EXIT_CODE
    fi
}

# Main command dispatcher
main() {
    # If no arguments provided, show help
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi
    
    # Parse command
    COMMAND="$1"
    shift
    
    case "$COMMAND" in
        install)
            cmd_install "$@"
            ;;
        test)
            cmd_test "$@"
            ;;
        lint)
            cmd_lint "$@"
            ;;
        format)
            cmd_format "$@"
            ;;
        export)
            cmd_export "$@"
            ;;
        release)
            cmd_release "$@"
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            echo "${RED}Error: Unknown command '$COMMAND'${NC}"
            echo
            show_help
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"
